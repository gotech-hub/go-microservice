//go:generate go run ./main.go
package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/doc"
	"go/parser"
	"go/token"
	"go/types"
	"io/fs"
	"os"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
	"text/template"
	"unicode"

	"golang.org/x/tools/go/packages"
)

var packageTemplate = template.Must(
	template.New("template").Funcs(template.FuncMap{
		"hasPrefix": strings.HasPrefix,
	}).Parse(tplText),
)

var listPackageGenerate []string

type GenerateTemplate struct {
	PackageName string
	Engine      []GenerateEngine
}

type GenerateEngine struct {
	CollectionName  string
	SnakeCollection string
	Fields          []FieldStruct
}

type FieldStruct struct {
	Field string
	Tag   string
	Type  string
}

func main() {
	err := getAllPackage()
	if err != nil {
		panic(err)
	}

	_, b, _, _ := runtime.Caller(0)
	baseDir := filepath.Dir(b)

	for _, pkg := range listPackageGenerate {
		pkgPath := filepath.Join(baseDir, "../repositories", pkg)
		tmplData, err := getPackageByPath(pkgPath)
		if err != nil {
			fmt.Printf("Error getting package %s: %v\n", pkgPath, err)
			continue
		}

		if len(tmplData.Engine) == 0 {
			continue
		}

		var buf bytes.Buffer
		writer := bufio.NewWriter(&buf)
		err = packageTemplate.Execute(writer, tmplData)
		if err != nil {
			fmt.Printf("‚ùå Error executing template for %s: %v\n", pkgPath, err)
			continue
		}
		writer.Flush()

		outputFile := filepath.Join(pkgPath, "name_generated.go")
		existing, err := os.ReadFile(outputFile)
		if err == nil && bytes.Equal(existing, buf.Bytes()) {
			fmt.Printf("‚è≠ Skipped (no changes): %s\n", outputFile)
			continue
		}

		err = os.WriteFile(outputFile, buf.Bytes(), fs.ModePerm)
		if err != nil {
			fmt.Printf("‚ùå Error writing file %s: %v\n", outputFile, err)
		} else {
			fmt.Printf("‚úÖ Updated: %s\n", outputFile)
		}
	}
}

var bsonTagRegex = regexp.MustCompile(`bson:"([^,"]+)(?:,omitempty)?"`)

func getAllPackage() error {
	rootDir := "../repositories"
	return filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() && path != rootDir {
			rel, _ := filepath.Rel(rootDir, path)
			rel = filepath.ToSlash(rel)
			listPackageGenerate = append(listPackageGenerate, rel)
		}
		return nil
	})
}

func getPackageByPath(pkgPath string) (GenerateTemplate, error) {
	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedTypes | packages.NeedFiles,
		Dir:  pkgPath,
	}
	pkgs, err := packages.Load(cfg)
	if err != nil || len(pkgs) == 0 {
		return GenerateTemplate{}, err
	}

	result := GenerateTemplate{PackageName: filepath.Base(pkgPath)}

	for _, pkg := range pkgs {
		scope := pkg.Types.Scope()
		for _, name := range scope.Names() {
			obj := scope.Lookup(name)
			typeName, ok := obj.(*types.TypeName)
			if !ok {
				continue
			}

			named, ok := typeName.Type().(*types.Named)
			if !ok || named.Underlying() == nil {
				continue
			}

			structType, ok := named.Underlying().(*types.Struct)
			if !ok || !shouldGenerate(named, pkgPath) {
				continue
			}

			engine := GenerateEngine{
				CollectionName:  typeName.Name(),
				SnakeCollection: toSnakeCase(typeName.Name()),
			}

			for i := 0; i < structType.NumFields(); i++ {
				tag := structType.Tag(i)
				matches := bsonTagRegex.FindStringSubmatch(tag)
				if len(matches) < 2 || matches[1] == "-" {
					continue
				}

				engine.Fields = append(engine.Fields, FieldStruct{
					Field: structType.Field(i).Name(),
					Tag:   matches[1],
					Type:  structType.Field(i).Type().String(),
				})
			}

			if len(engine.Fields) > 0 {
				fmt.Printf("üîß Found struct: %s (%d fields)\n", engine.CollectionName, len(engine.Fields))
				result.Engine = append(result.Engine, engine)
			}
		}
	}

	return result, nil
}

func shouldGenerate(typ *types.Named, pkgPath string) bool {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, pkgPath, nil, parser.ParseComments)
	if err != nil {
		return false
	}

	for _, p := range pkgs {
		docPkg := doc.New(p, pkgPath, 0)
		for _, t := range docPkg.Types {
			if t.Name == typ.Obj().Name() && strings.Contains(t.Doc, "generate model") {
				return true
			}
		}
	}
	for i := 0; i < typ.NumMethods(); i++ {
		if typ.Method(i).Name() == "CollectionName" {
			return true
		}
	}
	return false
}

func toSnakeCase(s string) string {
	var result []rune
	for i, r := range s {
		if unicode.IsUpper(r) && i > 0 {
			result = append(result, '_')
		}
		result = append(result, unicode.ToLower(r))
	}
	return string(result)
}

const tplText = `// Code generated by go generate; DO NOT EDIT.
// Generated constants for collection and field names and filter helpers.

package {{.PackageName}}

import (
	"time"
	"go.mongodb.org/mongo-driver/bson"
)

{{range .Engine}}
const (
	Col{{.CollectionName}} = "{{.SnakeCollection}}"
	{{- $Collection := .CollectionName }}
	{{- range .Fields }}
	F{{$Collection}}{{.Field}} = "{{.Tag}}"
	{{- end }}
)

{{- $Collection := .CollectionName }}
{{- range .Fields }}
// by{{.Field}} filters where {{.Tag}} == value
func by{{.Field}}(value {{.Type}}) bson.M {
	return bson.M{
		F{{$Collection}}{{.Field}}: value,
	}
}

// by{{.Field}}Not filters where {{.Tag}} != value
func by{{.Field}}Not(value {{.Type}}) bson.M {
	return bson.M{
		F{{$Collection}}{{.Field}}: bson.M{"$ne": value},
	}
}

{{- if and (ne .Type "time.Time") (not (hasPrefix .Type "[]")) }}
// by{{.Field}}In filters where {{.Tag}} in values
func by{{.Field}}In(values []{{.Type}}) bson.M {
	return bson.M{
		F{{$Collection}}{{.Field}}: bson.M{"$in": values},
	}
}

// by{{.Field}}NotIn filters where {{.Tag}} not in values
func by{{.Field}}NotIn(values []{{.Type}}) bson.M {
	return bson.M{
		F{{$Collection}}{{.Field}}: bson.M{"$nin": values},
	}
}
{{- end }}

{{- if eq .Type "time.Time" }}
// by{{.Field}}After filters where {{.Tag}} > value
func by{{.Field}}After(value time.Time) bson.M {
	return bson.M{
		F{{$Collection}}{{.Field}}: bson.M{"$gt": value},
	}
}

// by{{.Field}}Before filters where {{.Tag}} < value
func by{{.Field}}Before(value time.Time) bson.M {
	return bson.M{
		F{{$Collection}}{{.Field}}: bson.M{"$lt": value},
	}
}

// by{{.Field}}AfterAndEqual filters where {{.Tag}} >= value
func by{{.Field}}AfterAndEqual(value time.Time) bson.M {
	return bson.M{
		F{{$Collection}}{{.Field}}: bson.M{"$gte": value},
	}
}

// by{{.Field}}BeforeAndEqual filters where {{.Tag}} <= value
func by{{.Field}}BeforeAndEqual(value time.Time) bson.M {
	return bson.M{
		F{{$Collection}}{{.Field}}: bson.M{"$lte": value},
	}
}
{{- end }}
{{end}}

{{end}}`
